import torch
import torch.optim as optim
import numpy as np

# Define the matching pennies game payoff matrix
payoff_matrix = torch.tensor([[1, -1], [-1, 1]])

# Define the number of players and their strategies
num_players = 2
num_strategies = [2, 2]

# Initialize the trainable parameters for each player
x = torch.zeros(num_strategies[0], requires_grad=True)
y = torch.zeros(num_strategies[1], requires_grad=True)

def mix(a,epsilon):
    return (1-epsilon)*a.max() + epsilon*a.sum()

# Define the exploitability function
def exploitability(x, y):
    # Calculate the expected payoff for each player when using mixed strategies x and y
    expected_payoff = torch.zeros(num_players)
    for i in range(num_players):
        other_players = list(range(num_players))
        other_players.remove(i)
        mixed_strategies = [x] if i == 0 else [y]
        mixed_strategies += [torch.ones(num_strategies[j]) / num_strategies[j] for j in other_players]
        expected_payoff[i] = torch.sum(torch.prod(torch.stack(torch.meshgrid(*mixed_strategies)), dim=0) * payoff_matrix[i])
    # Calculate the exploitability as half the sum of the differences between the expected payoffs and their maxima
    return 0.5 * torch.sum(torch.abs(expected_payoff - torch.max(expected_payoff)))

# Define the BRE algorithm
def BRE(x, y, num_iterations=10, learning_rate=0.1):
    x_arr, y_arr = [], []
    optimizer_x = optim.SGD([x], lr=learning_rate)
    optimizer_y = optim.SGD([y], lr=learning_rate)
    for iteration in range(num_iterations):
        # Calculate the exploitability function
        f = exploitability(x, y)
        # Calculate the gradients of f with respect to x and y using backpropagation
        gradients_x, gradients_y = torch.autograd.grad(f, [x, y], create_graph=True)
        # Update the values of x and y using the gradient descent algorithm
        x.data -= learning_rate * (torch.sum(torch.stack([torch.max(payoff_matrix[:, j] + gradients_x[j]) for j in range(num_strategies[0])]) - torch.sum(payoff_matrix * x.unsqueeze(1)), dim=0))
        y.data -= learning_rate * (torch.sum(torch.stack([torch.sum(f * y[j]) for j in range(num_strategies[1])]), dim=0))
        # Zero out the gradients for the next iteration
        optimizer_x.zero_grad()
        optimizer_y.zero_grad()
        # Store the values of x and y for plotting
        x_arr.append(x.detach().numpy())
        y_arr.append(y.detach().numpy())
        print("Iteration:", iteration, "Exploitability:", f.detach().numpy())
        print("x:", x.detach().numpy())
        print("y:", y.detach().numpy())
    return x.detach().numpy(), y.detach().numpy(), x_arr, y_arr

# Test the BRE algorithm on the matching pennies game
x_optimal, y_optimal,x_arr,y_arr = BRE(x, y)
print("Optimal mixed strategies for player 1:", x_optimal)
print("Optimal mixed strategies for player 2:", y_optimal)

# Plot the values of x and y over the course of the algorithm
import matplotlib.pyplot as plt
plt.plot(x_arr)
plt.plot(y_arr)
plt.legend(["x", "y"])
plt.show()
