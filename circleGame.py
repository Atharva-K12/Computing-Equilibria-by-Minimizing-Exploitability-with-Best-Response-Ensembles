import torch
import numpy as np
from scipy.spatial.distance import pdist, squareform


class CircleGame(torch.nn.Module):
    def __init__(self, n_players):
        super().__init__()
        self.n_players = n_players
        self.action_dim = 1
        self.action_space = torch.linspace(-np.pi, np.pi, 100)
        self.register_parameter('x', torch.nn.Parameter(torch.randn(n_players, 2)))
        self.register_parameter('log_s', torch.nn.Parameter(torch.randn(n_players)))
        
    def get_action(self):
        with torch.no_grad():
            mus = torch.atan2(self.x[:, 1], self.x[:, 0])
            sigmas = torch.exp(self.log_s)
            actions = torch.zeros(self.n_players, self.action_dim)
            for i in range(self.n_players):
                actions[i] = torch.distributions.von_mises.VonMises(mus[i], sigmas[i]).sample()
            return actions
        
    def pairwise_distances(self, actions):
        diffs = actions.unsqueeze(0) - actions.unsqueeze(1)
        return torch.min(torch.abs(diffs), 2 * np.pi - torch.abs(diffs))
        
    def forward(self, actions):
        dists = self.pairwise_distances(actions)
        rewards = -dists[:, :-1] + dists[:, -1:]
        return rewards
        
        
def best_response(game, actions, player_idx):
    def objective(action):
        actions[player_idx] = action
        rewards = game.forward(actions)
        return -rewards[player_idx].sum()
    
    res = torch.optim.minimize_scalar(objective, bounds=[-np.pi, np.pi], method='bounded')
    return res.x
        
        
def exploitability(game, strategies):
    n_samples = 100
    actions = torch.zeros(game.n_players, game.action_dim)
    values = []
    for i in range(game.n_players):
        opponent_strategies = torch.cat((strategies[:i], strategies[i+1:]), dim=0).unsqueeze(0)
        # expected_rewards = torch.zeros(n_samples)
        for j in range(n_samples):
            actions[i] = torch.distributions.von_mises.VonMises(0, 1).sample()
            expected_rewards = 0
            for opponent_action in opponent_strategies:
                tempTensor = opponent_action.unsqueeze(0)
                if i != 0:
                    tempTensor = torch.cat((actions[:i], tempTensor), dim=0)
                if i != game.n_players - 1:
                    tempTensor = torch.cat((tempTensor, actions[i+1:]), dim=0)
                expected_rewards += game.forward(tempTensor).max()
            values.append(expected_rewards.max())
    return np.mean(values)
        
        
def best_response_ensemble(game, strategies, n_samples):
    for i in range(game.n_players):
        opponent_strategies = torch.cat((strategies[:i], strategies[i+1:]), dim=0).unsqueeze(0)
        action_samples = torch.zeros((n_samples, game.action_dim))
        expected_rewards = torch.zeros(n_samples)
        for j in range(n_samples):
            action_samples[j] = torch.distributions.von_mises.VonMises(0, 1).sample()
            for opponent_action in opponent_strategies:
                tempTensor = opponent_action.unsqueeze(0)
                if j != 0:
                    tempTensor = torch.cat((action_samples[:j], tempTensor), dim=0)
                if j != n_samples - 1:
                    tempTensor = torch.cat((tempTensor, action_samples[j+1:]), dim=0)
                expected_rewards[j] += game.forward(tempTensor).max()

        if i < game.n_players - 1:
            best_idx = expected_rewards.argmax()
        else:
            best_idx = expected_rewards.argmin()
        
        strategies[i] = action_samples[best_idx]
    return strategies
        
        
game = CircleGame(n_players=2)
strategies = [torch.zeros(game.action_dim) for _ in range(game.n_players)]
strategies = torch.tensor(strategies)
print("Strategies: ")
print(strategies)
exp_list = []
for i in range(1):
    strategies = best_response_ensemble(game, strategies, n_samples=3)
    exp = exploitability(game, strategies)
    print("strategies: ")
    print(strategies)
    exp_list.append(exp)
    if i % 1 == 0:
        print(f'Iteration {i}, exploitability: {exp}')


# plot exploitability
import matplotlib.pyplot as plt
plt.plot(exp_list)
plt.show()








                
                # tempTensor = torch.cat((action_samples[:j], opponent_action.unsqueeze(0), action_samples[j+1:]), dim=1)

                # tempTensor = None
                # if j == 0:
                #     # print("j == 0")
                #     # print(opponent_action.unsqueeze(0).shape)
                #     # print(action_samples[j+1:, i:].shape)
                #     tempTensor = torch.cat((opponent_action.unsqueeze(0), action_samples[j+1:,i:]), dim=0)
                # elif j == n_samples - 1:
                #     # print("j == 1")
                #     # print(opponent_action.unsqueeze(0).shape)
                #     # print(action_samples[:j, :i].shape)
                #     tempTensor = torch.cat((action_samples[:j, :i], opponent_action.unsqueeze(0)), dim=0)
                # else:
                #     # print("j == 2")
                #     # print(opponent_action.unsqueeze(0).shape)
                #     # print(action_samples[j+1:, i:].shape)
                #     # print(action_samples[:j, :i].shape)
                #     tempTensor = torch.cat((action_samples[:j, :i], opponent_action.unsqueeze(0), action_samples[j+1:, i:]), dim=0)


                # print(torch.cat((action_samples[:j, :i], opponent_action, action_samples[:j, i+1:]), dim=1))