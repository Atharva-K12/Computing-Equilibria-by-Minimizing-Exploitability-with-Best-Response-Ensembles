from typing import Callable
from dataclasses import dataclass
from functools import partial
from operator import neg
from jax import random, numpy as jnp, grad, vmap, tree_map


def replace(lst, index, value):
    return lst[:index] + [value] + lst[index+1:]


def mix(x, eps):
    return (1 - eps) * x.max() + eps * x.sum()


@dataclass
class BestResponseEnsembles:
    util_fn: Callable  # utility function
    size: int  # ensemble size
    init_fn: Callable  # strategy profile initialization function
    eps: float = .5

    def init_params(self, key):
        x_key, w_key = random.split(key)
        x = self.init_fn(x_key)
        w = vmap(self.init_fn)(random.split(w_key, self.size))
        return x, w  # profile and ensembles

    def get_profile_params(self, params):
        x, w = params
        return x

    def grads(self, params, key):
        u = partial(self.util_fn, key=key)

        def exploit_fn(x, w, fn):
            return sum(
                fn(vmap(lambda yi: u(replace(x, i, yi))[i])(ens))
                for i, ens in enumerate(w)
            ) - u(x).sum()

        x, w = params
        gx = grad(exploit_fn, 0)(x, w, jnp.max)
        gw = grad(exploit_fn, 1)(x, w, partial(mix, eps=self.eps))
        return tree_map(neg, gx), gw


