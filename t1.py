from typing import Callable
from dataclasses import dataclass
from functools import partial
from operator import neg
from jax import jit, random , numpy as jnp , grad , vmap , tree_map

# Matching Pennies game
A = jnp.array([[1, -1], [-1, 1]])

def utility(x, key):
    # print("In utility ",x.shape)
    return jnp.dot(x, jnp.dot(A, x))

def replace(lst, index, value):
    lst = list(lst)
    if len(lst) <= index:
        pass
    elif len(lst)-1 == index:
        lst = lst[:index] + [value]
        # print("In replace ",len(lst),index,sep =" \t")
    else:
        lst = lst[:index] + [value] + lst[index+1:]
        # print("In replace3 ",len(lst),index,sep =" \t")

    return jnp.array(lst)

def mix(x, eps):
    return (1 - eps) * x.max() + eps * x.sum()

@dataclass
class BestResponseEnsembles:
    util_fn: Callable # utility function
    size: int # ensemble size
    init_fn: Callable # strategy profile initialization function
    eps: float = .5

    def init_params(self, key):
        x_key, w_key = random.split(key)
        x = self.init_fn(x_key)
        w = vmap(self.init_fn)(random.split(w_key, self.size))
        w=jnp.transpose(w)
        # print("In init_params ",x.shape,w.shape)
        return x, w # profile and ensembles

    def get_profile_params(self, params):
        x, w = params
        return x

    def grads(self, params, key):
        u = partial(self.util_fn, key=key)

        # def exploit_fn(x, w, fn):
        #     print("In exploit_fn ",x.shape)
        #     return sum(
        #         fn(vmap(lambda yi: u(replace(x, i, yi)))(ens))
        #         for i, ens in enumerate(w)
        #     ) - u(x).sum()
        def exploit_fn(x, w, fn):
            # Calculate the utility of the original profile
            u_x = u(x).sum()

            # Calculate the expected utility of exploiting each player's strategy
            u_exploit = 0
            for i, ens in enumerate(w):
                # print("In exploit_fn ",i)
                u_ens = vmap(lambda yi: u(replace(x, i, yi)))(ens)
                u_exploit += fn(u_ens)

            # Calculate the gain in utility from exploiting the profile
            return u_exploit - u_x

        x, w = params
        gx = grad(exploit_fn, 0)(x, w, jnp.sum)
        # gw = tree_map(grad(exploit_fn, 1), w, jnp.sum)
        gw = tree_map(lambda ens: grad(exploit_fn, 1)(x,ens, jnp.sum), w)
        # print("\n\n\n\n In grad\n\n\n\n\n ",gx,gw,gx.shape,gw.shape, sep = "\t")
        return gx, gw



import jax.random as random
import jax.experimental#.optimizers as optimiser
from jax.example_libraries import optimizers
import matplotlib.pyplot as plt

# Initialize BestResponseEnsembles object
best_response_ensembles = BestResponseEnsembles(
    util_fn=utility,
    size=10,
    init_fn = lambda key: random.uniform(key, (2,))
)

exploitabilities = []
best_exploitability = float('inf')

# Set up optimization loop
opt_init, opt_update, get_params = optimizers.adam(step_size=0.1)
opt_state = opt_init(best_response_ensembles.init_params(random.PRNGKey(0)))

for i in range(1000):
    # Compute gradients
    params = get_params(opt_state)
    gx, gw = best_response_ensembles.grads(params, random.PRNGKey(i))
    grads = gx, gw

    # Update optimizer state
    opt_state = opt_update(i, grads, opt_state)

    x = best_response_ensembles.get_profile_params(get_params(opt_state))
    u = utility(x, random.PRNGKey(i))
    exploitability = u.max() - u.min()
    exploitabilities.append(exploitability)

    # Update best exploitability if necessary
    if exploitability < best_exploitability:
        best_exploitability = exploitability

    # Print current strategy profile and best exploitability
    if i % 100 == 0:
        print(f"Epoch {i}: x = {x}, exploitability = {exploitability}, best exploitability = {best_exploitability}")

# Plot exploitabilities
plt.plot(exploitabilities)
plt.title("Best Exploitability by Epoch")
plt.xlabel("Epoch")
plt.ylabel("Best Exploitability")
plt.show()