import torch
import torch.nn as nn
import torch.nn.functional as F
import numpy as np

class circleGamePlayer(nn.Module):
    def __init__(self):
        super().__init__()
        self.action_dim = 1
        self.action_space = torch.linspace(-np.pi, np.pi, 100)
        self.register_parameter('x', torch.nn.Parameter(torch.randn(2)))
        self.register_parameter('log_s', torch.nn.Parameter(torch.randn(1)))
        self.mu = torch.atan2(self.x[1], self.x[0])
        self.sigma = torch.exp(self.log_s)
        self.vonMises = torch.distributions.von_mises.VonMises(self.mu, self.sigma)
        self.action = self.vonMises.sample()
        self.strategy = self.vonMises.sample()
        self.optimizer = torch.optim.SGD(self.parameters(), lr=0.001)
        self.action_optimizer = torch.optim.SGD(self.parameters(), lr=0.001)
        self.reward = 0
    
class CircleGame(nn.Module):
    def __init__(self, n_players):
        super().__init__()
        self.n_players = n_players
        self.players = [circleGamePlayer() for i in range(n_players)]

    def pairwise_distances(self, actions):
        diffs = actions.unsqueeze(0) - actions.unsqueeze(1)
        return torch.min(torch.abs(diffs), 2 * np.pi - torch.abs(diffs))
    
    def loss(self, actions):
        dists = self.pairwise_distances(actions)
        rewards = -dists[:, :-1] + dists[:, -1:]
        return rewards
    
    def train(self, n_epochs,lr):
        optimizer = torch.optim.SGD(self.parameters(), lr=lr)
        for i in range(n_epochs):
            for 


    